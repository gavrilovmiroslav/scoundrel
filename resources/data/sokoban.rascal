
unique terrain: field of symbol;
event MoveIntent { e: entity, p: num, q: num };

func CreateRoom(min_width: num, max_width: num,
                min_height: num, max_height: num,
                attempts: num, room_space: set) {

    for i in 0 to attempts {
        let w = rand(min_width, max_width);
        let h = rand(min_height, max_height);
        let x = rand(1, 64 - w);
        let y = rand(1, 48 - h);

        let outer = rectangle(x, y; x + w, y + h);
        let inner = rectangle(x + 1, y + 1; x + w - 1, y + h - 1);
        if empty(intersect(room_space, inner)) {
            room_space = union(room_space, outer);
            terrain[inner] = '.';
        }
    }
}

func TestMut(x: set) {
    debug print "2: " + empty(x);
    x = union(x, rectangle(10, 10; 20, 20));
    debug print "3: " + empty(x);
}

[Spawn Player On Start]
on Start
{
    spawn player with
        IsPlayer
      & IsAt(20, 20)
      & HasGlyph('@')
      & HasColor(0, 0, 255);

    let room_space = make_set();

    //[CreateRoom: 10, 15; 8, 12; 100; room_space];
    //[CreateRoom: 5,  12; 5, 11; 500;  room_space];
    //[CreateRoom: 4,  9;  4, 8;  100; room_space];

    debug print "1: " + empty(room_space);
    [TestMut: room_space];
    debug print "4: " + empty(room_space);
    terrain[room_space] = '2';
}

// ===== KEYBOARD EVENTS =====================================

[Move By Keyboard|first]
on KeyPress(key, "Pressed")
with e.IsPlayer & e.IsAt(x, y)
{
    let p = x, q = y;
    match key {
        case "Left": p = x - 1;
        case "Right": p = x + 1;
        case "Up": q = y - 1;
        case "Down": q = y + 1;
    } then {
        trigger MoveIntent(e, p, q);
        consume event;
    }
}

[Do Move Intent|last]
on MoveIntent(e, p, q)
with e.IsPlayer & e.IsAt(x, y)
{
    x = p;
    y = q;
    consume event;
}

[Draw Terrain]
with unique(terrain)
{
    print terrain;
}